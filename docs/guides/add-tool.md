# Guide: Add Tool

Tools are the only means by which the agent performs real work. During skill job execution, the Skill Planner selects tools and the Job Runner calls them sequentially.

---

## Tool Interface

**File:** `src/lib/tools/registry.ts`

```typescript
interface Tool {
  name: string;           // Unique identifier. Skill Planner references by this name
  description: string;    // Description shown to LLM. Write clearly
  inputSchema: object;    // JSON Schema (OpenAI function calling format)
  run(
    input: Record<string, unknown>,
    context: ToolContext
  ): Promise<ToolResult>;
}

interface ToolContext {
  userId: string;  // ID of user who requested the job
  jobId?: string;  // ID of currently running job
}

interface ToolResult {
  output: unknown;          // Result on success. Must be JSON serializable
  artifactPath?: string;    // Path to file generated by tool (optional)
  error?: string;           // Error message. If present, recorded in step_runs.error
}
```

---

## Adding a New Tool

### Step 1: Create Tool File

Create a file at `src/lib/tools/{tool_name}.ts`.

**Template:**
```typescript
import { registerTool } from './registry';

registerTool({
  name: 'my_tool',                           // snake_case recommended
  description: 'Does X given Y input',       // LLM selects tool based on this description
  inputSchema: {
    type: 'object',
    properties: {
      param1: { type: 'string', description: '...' },
      param2: { type: 'number', description: '...' },
    },
    required: ['param1'],                    // Only include required parameters
  },
  async run(input, context) {
    try {
      // Parameters always need type assertion (input is Record<string, unknown>)
      const param1 = input.param1 as string;
      const param2 = (input.param2 as number) || 0;

      // Perform work
      const result = await doWork(param1, param2);

      return { output: result };
    } catch (e: unknown) {
      return { output: null, error: String(e) };
    }
  },
});
```

### Step 2: Add import to runner.ts

**File:** `src/lib/jobs/runner.ts`

```typescript
// Ensure tools are registered
import '../tools/summarize';
import '../tools/remember';
import '../tools/search';
import '../tools/list_memory';
import '../tools/my_tool';    // ← add here
```

> **CRITICAL:** Missing this import means the tool won't be registered. `getTool('my_tool')` returns `undefined` and the step is recorded with error `"Tool 'my_tool' not found"`.

### Step 3: Verify it works

How to confirm the tool is registered correctly:

```bash
# Create a job via API and run it immediately
curl -X POST http://localhost:3000/api/jobs \
  -H "Content-Type: application/json" \
  -d '{
    "skillId": null,
    "triggerType": "manual",
    "input": {},
    "runNow": false
  }'

# Create a skill that uses my_tool via Skill Planner and run the job
```

---

## Real Implementation Examples

### summarize tool (calls OpenAI)
**File:** `src/lib/tools/summarize.ts`

```typescript
import { registerTool } from './registry';
import OpenAI from 'openai';

registerTool({
  name: 'summarize',
  description: 'Summarizes text using LLM',
  inputSchema: {
    type: 'object',
    properties: {
      text: { type: 'string', description: 'Text to summarize' },
      maxLength: { type: 'number', description: 'Maximum summary length in words' },
    },
    required: ['text'],
  },
  async run(input) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) return { output: null, error: 'OPENAI_API_KEY not set' };

    const openai = new OpenAI({ apiKey });
    const maxLength = (input.maxLength as number) || 100;
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: `Summarize in ${maxLength} words:\n\n${input.text}` }],
      max_tokens: maxLength * 2,
    });
    return { output: completion.choices[0]?.message?.content || '' };
  },
});
```

### remember tool (writes to memory)
**File:** `src/lib/tools/remember.ts`

```typescript
import { registerTool } from './registry';
import { writeNote } from '../memory/notes';
import type { NoteKind } from '../memory/notes';

registerTool({
  name: 'remember',
  description: 'Writes a memory note for the user',
  inputSchema: {
    type: 'object',
    properties: {
      content: { type: 'string' },
      kind: { type: 'string', enum: ['log', 'summary', 'rule', 'soul'] },
      tags: { type: 'array', items: { type: 'string' } },
    },
    required: ['content'],
  },
  async run(input, context) {
    const note = writeNote({
      kind: (input.kind as NoteKind) || 'log',
      content: input.content as string,
      userId: context.userId,    // ← get userId from context
      tags: (input.tags as string[]) || [],
      jobId: context.jobId,      // ← get jobId from context
    });
    return { output: { noteId: note.id, success: true } };
  },
});
```

---

## Anti-Patterns

### ❌ Throwing errors

```typescript
// Wrong: throwing causes Job Runner to treat it as step error
async run(input) {
  throw new Error('Something went wrong');
}

// Correct: return ToolResult.error
async run(input) {
  return { output: null, error: 'Something went wrong' };
}
```

### ❌ Missing runner.ts import

```typescript
// Without this line in runner.ts, the tool is not registered
import '../tools/my_tool';
```

### ❌ Accessing memory without context

```typescript
// Wrong: writing note without userId
async run(input) {
  writeNote({ kind: 'log', content: '...' });  // no userId
}

// Correct: use context.userId
async run(input, context) {
  writeNote({ kind: 'log', content: '...', userId: context.userId });
}
```

### ❌ Returning non-JSON-serializable values

```typescript
// Wrong: non-serializable values (Map, Date, etc.)
return { output: new Map([['key', 'val']]) };

// Correct: plain objects/arrays/primitives
return { output: { key: 'val' } };
```

---

## Relationship Between Skills and Tools

```mermaid
graph LR
    Skill[Skill\ngoal + tools array] -->|planSkill()| Planner[Skill Planner\nOpenAI]
    Planner -->|Plan.steps| Runner[Job Runner]
    Runner -->|getTool\(name\)| Registry[Tool Registry]
    Registry --> Tool1[summarize]
    Registry --> Tool2[remember]
    Registry --> Tool3[list_memory]
    Registry --> Tool4[web_search]
    Registry --> Tool5[bash]
    Registry --> ToolN[...]
```

If a skill's `tools` field is an empty array, all tools are exposed to the Planner.
To allow only specific tools, specify names explicitly: `tools: ["summarize", "remember"]`.
